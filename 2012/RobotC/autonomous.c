#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     GYRO,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     L1,             sensorLightActive)
#pragma config(Sensor, S4,     L2,             sensorLightActive)
#pragma config(Motor,  mtr_S1_C1_1,     motorE,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorF,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorG,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorH,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     motorI,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_2,     motorJ,        tmotorTetrix, PIDControl, encoder)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#include "drivers/hitechnic-gyro.h"
#include "armKinetics.c"
#include "heading.c"
#include "coordinatedArm1.c"


typedef struct {
   int enc1;
   int enc2;
} encMove;
/*===================================================================================================================*/

void checkIRSensor(bool &lightOne, bool &lightTwo) {
	if(SensorValue(S3) <= 0) {
		lightOne = true;
		//code here for light sensor / movement to next line (copy from task main)
	}else{
   	lightOne = false;
		//put code here for arm movement / placement of ring
	}

	if(SensorValue(S4) <= 0) {
		lightTwo = true;
		//code here for light sensor / movement to next line (copy from task main)
	}else{
   	lightTwo = false;
		//put code here for arm movement / placement of ring
	}

}
/*===================================================================================================================*/

void changePosition(const string direction, int speed, int distance) {
	nMotorEncoder[motorE] = 0;
	nMotorEncoder[motorF] = 0;
	nMotorEncoder[motorG] = 0;
	nMotorEncoder[motorH] = 0;
	if(direction == "forward") {
		while(nMotorEncoder[motorE] < distance) {
			motor[motorE] =  speed;
			motor[motorG] =  -speed;
		}
		motor[motorE] =  0;
		motor[motorG] =  0;
	}

	if(direction == "back") {
		while(nMotorEncoder[motorG] < distance) {
			motor[motorE] =  -speed;
			motor[motorG] =  speed;
		}
		motor[motorF] =  0;
		motor[motorH] =  0;
	}

	if(direction == "left") {
		while(nMotorEncoder[motorH] < distance) {
			motor[motorF] =  -speed;
			motor[motorH] =  speed;
		}
		motor[motorF] =  0;
		motor[motorH] =  0;
	}

	if(direction == "right") {
		while(nMotorEncoder[motorF] < distance) {
			motor[motorF] =  speed;
			motor[motorH] =  -speed;
		}
		motor[motorF] =  0;
		motor[motorH] =  0;
	}
	if(direction == "turn") {
		if(speed > 0) {
			while(nMotorEncoder[motorF] < distance) {
				motor[motorE] = speed;
				motor[motorG] = speed;
				motor[motorF] = speed;
				motor[motorH] = speed;
			}
		}else{
			while(nMotorEncoder[motorF] > -distance) {
				motor[motorE] = speed;
				motor[motorG] = speed;
				motor[motorF] = speed;
				motor[motorH] = speed;
			}
		}
		motor[motorE] = 0;
		motor[motorG] = 0;
		motor[motorF] = 0;
		motor[motorH] = 0;
	}

}
/*===================================================================================================================*/
/*===================================================================================================================*/

void positionArmControl(rectangular &rectPos) {
	encMove enc;
	armState anglePos;
	solveArmFromWristPos(anglePos, rectPos);
	enc.enc1 = radiansToDegrees(anglePos.qe) * 4.0 * 6.0;   // 4 ticks to a degree, gear ratio 6
	enc.enc2	= radiansToDegrees(anglePos.qs) * 4.0 * 9.0;	// 4 ticks to a degree, gear ratio 9
	nxtDisplayTextLine(5, "Qe = %f", anglePos.qe);
	nxtDisplayTextLine(6, "Qs = %f", anglePos.qs);
	nMotorEncoderTarget[motorI] = enc.enc2;
	nMotorEncoderTarget[motorJ] = enc.enc1;
	motor[motorI] = -20;
	motor[motorJ] = 30;
	while(nMotorRunState[motorI] != runStateIdle || nMotorRunState[motorJ] != runStateIdle)  // while Motors is still running:
	{
  		// Do not continue.
	}
	motor[motorI] = 0;
	motor[motorJ] = 0;
}
/*===================================================================================================================*/

task main()
{
	StartTask(heading);
	rectangular position;
	waitForStart();

//to move robot call procedure "changePosition(direction, speed, distance)"
//direction should be forward, back, left, or right (it's a character)
//speed and distance are both integers, speed is 0-100 distance is encoder counts.

	//changePosition("forward", 50, 4000);
	//changePosition("left", 50, 3000);
	//changePosition("turn", 50, 700);

	changePosition("turn", 50, 500);
/*===================================================================================================================*/
//attempt to climb onto board
/*	motor[motorF] = 75;
	motor[motorG] = 75;
	wait10Msec(200);
	motor[motorF] = 0;
	motor[motorG] = 0; */
/*===================================================================================================================*/
	position.x = 0.0;
	position.y = 2.0;
	//positionArmControl(position);

//move left until either light sensor detects, then switch majority power to the other side to align robot
/*	while(SensorValue[lightSensor1] < 50 && SensorValue[lightSensor2] < 50) {
		changePosition("left", 50, 10);
	}
	if(SensorValue[lightSensor1] > 50) {
		while(SensorValue[lightSensor2] <50) {
			motor[motorF] = 20;
		}
	}
	if(SensorValue[lightSensor2] > 50) {
		while(SensorValue[lightSensor1] < 50) {
			motor[motorE] = 20;
		}
	} */
// check the IR sensor (then move to the next white line until it is detected)


}
