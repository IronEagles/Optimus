#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     ,               sensorTouch)
#pragma config(Sensor, S3,     IRsensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S4,     GYRO,           sensorI2CHiTechnicGyro)
#pragma config(Motor,  mtr_S1_C1_1,     motorLeft,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorRight,    tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorH,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorI,        tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C4_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "drivers/hitechnic-gyro.h"
float currHeading = 0.0;

void goToIR()
{
	nMotorEncoder[motorLeft] = 0;
	nMotorEncoder[motorRight] = 0;
	PlayTone(220, 15);
  motor[motorLeft] = 30;
	motor[motorRight] = 30;
	PlayTone(784, 15);
	while(SensorValue[IRsensor] != 4)  // infinite loop:
	{
  	nxtDisplayCenteredTextLine(2, "Sensor Value: %d", SensorValue[IRsensor]);  // display "Sensor Value: ##"
  	wait1Msec(10);  // Wait 100 milliseconds to help display correctly
	}

	motor[motorLeft] = 0;
	motor[motorRight] = 0;
	PlayTone(784, 15);  // play a tone at a frequency of 784 for 150 milliseconds
}

void FunctionToWall()
{
	//Score Autonomus goes here XD

	motor[motorLeft] = 30;
	motor[motorRight] = 30;
	while(nMotorEncoder[motorRight] > 360 * 4 * 10.6 * -1)
	{
		nxtDisplayCenteredTextLine(4, "Encoder: %d", nMotorEncoder[motorRight]);
		wait1Msec(10);
	}

	motor[motorLeft] = 0;
	motor[motorRight] = 0;
}
void driveDistance(int power, int distance)
{
	if(power < 0)
	{
		distance = nMotorEncoder[motorRight] + distance;
		if(power > 0)
		{
			while(nMotorEncoder[motorRight] < distance)
			{
				motor[motorLeft] = power;
				motor[motorRight] = power;
			}
		}else
		{
			while(nMotorEncoder[motorRight] > distance)
			{
				motor[motorLeft] = power;
				motor[motorRight] = power;
			}
		}
	}
	else
	{
		distance = nMotorEncoder[motorRight] + distance;
		while(nMotorEncoder[motorRight] < distance)
		{
			motor[motorLeft] = power;
			motor[motorRight] = power;
		}
	}

	motor[motorLeft] = 0;
	motor[motorRight] = 0;
}
void FunctionTurn()
{
	//90 Degree Turn
	motor[motorLeft] = 30;
	motor[motorRight] = -30;
}

void FunctionToWhiteLine()
{
	//White Line to Ramp
	int lightval = 0;

	motor[motorLeft] = 30;
	motor[motorRight] = 30;

	while(SensorValue(S2) <= (lightval + 4))
	{
  	nxtDisplayCenteredTextLine(1, "Sensor Value: %d", SensorValue(S2));  // display "Sensor Value: ##"
  	wait1Msec(10);  // Wait 100 milliseconds to help display correctly
	}

	motor[motorLeft] = 0;
	motor[motorRight] = 0;
	PlayTone(784, 15);  // play a tone at a frequency of 784 for 150 milliseconds
	wait1Msec(1000);
}

void gyroTurn(int power, float turn)
{
	currHeading = 0.0;
	motor[motorLeft] = power;
	motor[motorRight] = -power;
	while(currHeading < (0.0+turn) || currHeading > (360.0-turn))
	{
		wait1Msec(20);
	}

	motor[motorLeft] = 0;
	motor[motorRight] = 0;

	wait1Msec(1000);
}


task heading()
{
	float delTime = 0.0;
	float prevHeading = 0.0;
	float curRate = 0.0;
	HTGYROstartCal(GYRO);
   while (true) {
   	time1[T1] = 0;
    	curRate = HTGYROreadRot(GYRO);
    	if (abs(curRate) > 5) {
      	prevHeading = currHeading;
      	currHeading = prevHeading + (curRate * delTime);
      	if (currHeading > 360) currHeading -= 360;
      	else if (currHeading < 0) currHeading += 360;
    		}
    nxtDisplayTextLine(3, "Curr = %f", currHeading);
   	wait1Msec(5);
    	delTime = ((float)time1[T1]) / 1000;
    	//delTime /= 1000;

	}
}
